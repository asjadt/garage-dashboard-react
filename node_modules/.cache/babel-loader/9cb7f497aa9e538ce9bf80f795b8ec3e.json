{"ast":null,"code":"/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = function split(undef) {\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n  self = function (str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + (\n      // Proposed for ES6\n      separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2,\n      match,\n      lastIndex,\n      lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 :\n    // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function () {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n  return self;\n}();","map":{"version":3,"names":["module","exports","split","undef","nativeSplit","String","prototype","compliantExecNpcg","exec","self","str","separator","limit","Object","toString","call","output","flags","ignoreCase","multiline","extended","sticky","lastLastIndex","RegExp","source","separator2","match","lastIndex","lastLength","index","length","push","slice","replace","i","arguments","Array","apply","test"],"sources":["/home/rifat/uk client/garage/garage-frontend-2/theme/node_modules/browser-split/index.js"],"sourcesContent":["/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAI,SAASC,KAAK,CAACC,KAAK,EAAE;EAEtC,IAAIC,WAAW,GAAGC,MAAM,CAACC,SAAS,CAACJ,KAAK;IACtCK,iBAAiB,GAAG,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAKL,KAAK;IAChD;IACAM,IAAI;EAENA,IAAI,GAAG,UAASC,GAAG,EAAEC,SAAS,EAAEC,KAAK,EAAE;IACrC;IACA,IAAIC,MAAM,CAACP,SAAS,CAACQ,QAAQ,CAACC,IAAI,CAACJ,SAAS,CAAC,KAAK,iBAAiB,EAAE;MACnE,OAAOP,WAAW,CAACW,IAAI,CAACL,GAAG,EAAEC,SAAS,EAAEC,KAAK,CAAC;IAChD;IACA,IAAII,MAAM,GAAG,EAAE;MACbC,KAAK,GAAG,CAACN,SAAS,CAACO,UAAU,GAAG,GAAG,GAAG,EAAE,KAAKP,SAAS,CAACQ,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC,IAAIR,SAAS,CAACS,QAAQ,GAAG,GAAG,GAAG,EAAE,CAAC;MAAG;MAChHT,SAAS,CAACU,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC;MAC7B;MACAC,aAAa,GAAG,CAAC;MACjB;MACAX,SAAS,GAAG,IAAIY,MAAM,CAACZ,SAAS,CAACa,MAAM,EAAEP,KAAK,GAAG,GAAG,CAAC;MACrDQ,UAAU;MAAEC,KAAK;MAAEC,SAAS;MAAEC,UAAU;IAC1ClB,GAAG,IAAI,EAAE,CAAC,CAAC;IACX,IAAI,CAACH,iBAAiB,EAAE;MACtB;MACAkB,UAAU,GAAG,IAAIF,MAAM,CAAC,GAAG,GAAGZ,SAAS,CAACa,MAAM,GAAG,UAAU,EAAEP,KAAK,CAAC;IACrE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIL,KAAK,GAAGA,KAAK,KAAKT,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;IAAG;IACrCS,KAAK,KAAK,CAAC,CAAC,CAAC;IACb,OAAOc,KAAK,GAAGf,SAAS,CAACH,IAAI,CAACE,GAAG,CAAC,EAAE;MAClC;MACAiB,SAAS,GAAGD,KAAK,CAACG,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM;MACzC,IAAIH,SAAS,GAAGL,aAAa,EAAE;QAC7BN,MAAM,CAACe,IAAI,CAACrB,GAAG,CAACsB,KAAK,CAACV,aAAa,EAAEI,KAAK,CAACG,KAAK,CAAC,CAAC;QAClD;QACA;QACA,IAAI,CAACtB,iBAAiB,IAAImB,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;UAC1CJ,KAAK,CAAC,CAAC,CAAC,CAACO,OAAO,CAACR,UAAU,EAAE,YAAW;YACtC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACL,MAAM,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;cAC7C,IAAIC,SAAS,CAACD,CAAC,CAAC,KAAK/B,KAAK,EAAE;gBAC1BuB,KAAK,CAACQ,CAAC,CAAC,GAAG/B,KAAK;cAClB;YACF;UACF,CAAC,CAAC;QACJ;QACA,IAAIuB,KAAK,CAACI,MAAM,GAAG,CAAC,IAAIJ,KAAK,CAACG,KAAK,GAAGnB,GAAG,CAACoB,MAAM,EAAE;UAChDM,KAAK,CAAC9B,SAAS,CAACyB,IAAI,CAACM,KAAK,CAACrB,MAAM,EAAEU,KAAK,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;QACpD;QACAJ,UAAU,GAAGF,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM;QAC5BR,aAAa,GAAGK,SAAS;QACzB,IAAIX,MAAM,CAACc,MAAM,IAAIlB,KAAK,EAAE;UAC1B;QACF;MACF;MACA,IAAID,SAAS,CAACgB,SAAS,KAAKD,KAAK,CAACG,KAAK,EAAE;QACvClB,SAAS,CAACgB,SAAS,EAAE,CAAC,CAAC;MACzB;IACF;;IACA,IAAIL,aAAa,KAAKZ,GAAG,CAACoB,MAAM,EAAE;MAChC,IAAIF,UAAU,IAAI,CAACjB,SAAS,CAAC2B,IAAI,CAAC,EAAE,CAAC,EAAE;QACrCtB,MAAM,CAACe,IAAI,CAAC,EAAE,CAAC;MACjB;IACF,CAAC,MAAM;MACLf,MAAM,CAACe,IAAI,CAACrB,GAAG,CAACsB,KAAK,CAACV,aAAa,CAAC,CAAC;IACvC;IACA,OAAON,MAAM,CAACc,MAAM,GAAGlB,KAAK,GAAGI,MAAM,CAACgB,KAAK,CAAC,CAAC,EAAEpB,KAAK,CAAC,GAAGI,MAAM;EAChE,CAAC;EAED,OAAOP,IAAI;AACb,CAAC,EAAG"},"metadata":{},"sourceType":"script"}