{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\nvar isNullOrUndefined = value => value == null;\nvar isArray = value => Array.isArray(value);\nconst isObjectType = value => typeof value === 'object';\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\nvar isHTMLElement = value => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nconst VALUE = 'value';\nconst UNDEFINED = 'undefined';\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst SELECT = 'select';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\nfunction attachEventListeners(_ref) {\n  let {\n    field: {\n      ref\n    },\n    handleChange,\n    isRadioOrCheckbox\n  } = _ref;\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\nvar isKey = value => !isArray(value) && (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\nvar stringToPath = string => {\n  const result = [];\n  string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\n    result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\n  });\n  return result;\n};\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\nvar transformToNestObject = data => Object.entries(data).reduce((previous, _ref2) => {\n  let [key, value] = _ref2;\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\nvar isUndefined = val => val === undefined;\nvar get = (obj, path, defaultValue) => {\n  const result = path.split(/[,[\\].]+?/).filter(Boolean).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\nvar isRadioInput = element => element.type === 'radio';\nvar isCheckBoxInput = element => element.type === 'checkbox';\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n  return isDetached(element.parentNode);\n}\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\nfunction baseGet(object, path) {\n  const updatePath = isKey(path) ? [path] : castPath(path);\n  const length = path.length;\n  let index = 0;\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n  return index == length ? object : undefined;\n}\nfunction baseSlice(array, start, end) {\n  let index = -1;\n  let length = array.length;\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start;\n  const result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\nfunction parent(object, path) {\n  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\nfunction baseUnset(object, path) {\n  const updatePath = isKey(path) ? [path] : castPath(path);\n  const childObject = parent(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  const result = !(childObject != null) || delete childObject[key];\n  let previousObjRef = undefined;\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n    if (k > 0) {\n      previousObjRef = object;\n    }\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n      if (currentPathsLength === index) {\n        if (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data)).length) {\n          previousObjRef ? delete previousObjRef[item] : delete object[item];\n        }\n      }\n      previousObjRef = objectRef;\n    }\n  }\n  return result;\n}\nfunction unset(object, paths) {\n  paths.forEach(path => {\n    baseUnset(object, path);\n  });\n  return object;\n}\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name,\n      type\n    },\n    mutationWatcher\n  } = field;\n  const fieldValue = fields[name];\n  if (!type) {\n    delete fields[name];\n    return;\n  }\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\n    const {\n      options\n    } = fieldValue;\n    if (isArray(options) && options.length) {\n      options.filter(Boolean).forEach((option, index) => {\n        const {\n          ref,\n          mutationWatcher\n        } = option;\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n          unset(options, [`[${index}]`]);\n        }\n      });\n      if (options && !options.filter(Boolean).length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldValue, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n    delete fields[name];\n  }\n}\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\nvar getMultipleSelectValue = options => [...options].filter(_ref3 => {\n  let {\n    selected\n  } = _ref3;\n  return selected;\n}).map(_ref4 => {\n  let {\n    value\n  } = _ref4;\n  return value;\n});\nvar isFileInput = element => element.type === 'file';\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\nvar isEmptyString = value => value === '';\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(_ref5 => {\n        let {\n          ref: {\n            value\n          }\n        } = _ref5;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n  return defaultResult;\n};\nfunction getFieldValue(fields, ref) {\n  const {\n    name,\n    value\n  } = ref;\n  const field = fields[name];\n  if (isFileInput(ref)) {\n    return ref.files;\n  }\n  if (isRadioInput(ref)) {\n    return field ? getRadioValue(field.options).value : '';\n  }\n  if (isMultipleSelect(ref)) {\n    return getMultipleSelectValue(ref.options);\n  }\n  if (isCheckBoxInput(ref)) {\n    return field ? getCheckboxValue(field.options).value : false;\n  }\n  return value;\n}\nvar isString = value => typeof value === 'string';\nvar getFieldsValues = (fields, search) => {\n  const output = {};\n  for (const name in fields) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) ? search.find(data => name.startsWith(data)) : search && search.nest)) {\n      output[name] = getFieldValue(fields, fields[name].ref);\n    }\n  }\n  return output;\n};\nvar compareObject = function () {\n  let objectA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let objectB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const objectAKeys = Object.keys(objectA);\n  const objectBKeys = Object.keys(objectB);\n  return objectAKeys.length === objectBKeys.length && objectAKeys.every(key => objectB[key] && objectB[key] === objectA[key]);\n};\nvar isSameError = (error, _ref6) => {\n  let {\n    type,\n    types,\n    message\n  } = _ref6;\n  return isObject(error) && error.type === type && error.message === message && compareObject(error.types, types);\n};\nfunction shouldRenderBasedOnError(_ref7) {\n  let {\n    errors,\n    name,\n    error,\n    validFields,\n    fieldsWithValidation\n  } = _ref7;\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n  if (isFieldValid && validFields.has(name) || existFieldError && existFieldError.isManual) {\n    return false;\n  }\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\nvar isRegex = value => value instanceof RegExp;\nvar getValueAndMessage = validationData => {\n  const isValueMessage = value => isObject(value) && !isRegex(value);\n  return isValueMessage(validationData) ? validationData : {\n    value: validationData,\n    message: ''\n  };\n};\nvar isFunction = value => typeof value === 'function';\nvar isBoolean = value => typeof value === 'boolean';\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\nfunction getValidateError(result, ref) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n  return {};\n};\nvar validateField = async (fieldsRef, validateAllFieldCriteria, _ref8) => {\n  let {\n    ref,\n    ref: {\n      type,\n      value,\n      name\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  } = _ref8;\n  var _a;\n  const fields = fieldsRef.current;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = isEmptyString(value);\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {\n    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n    if (!validateAllFieldCriteria) {\n      return error;\n    }\n  };\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value: requiredValue,\n      message: requiredMessage\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n    if (requiredValue) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (validate) {\n    const fieldValue = getFieldValue(fields, ref);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n  return error;\n};\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner) ? error.inner.reduce((previous, _ref9) => {\n  let {\n    path,\n    message,\n    type\n  } = _ref9;\n  return Object.assign(Object.assign({}, previous), path ? previous[path] && validateAllFieldCriteria ? {\n    [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message)\n  } : {\n    [path]: previous[path] || Object.assign({\n      message,\n      type\n    }, validateAllFieldCriteria ? {\n      types: {\n        [type]: message || true\n      }\n    } : {})\n  } : {});\n}, {}) : {\n  [error.path]: {\n    message: error.message,\n    type: error.type\n  }\n};\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\n  if (validationResolver) {\n    return validationResolver(data, context);\n  }\n  try {\n    return {\n      values: await validationSchema.validate(data, {\n        abortEarly: false,\n        context\n      }),\n      errors: {}\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria))\n    };\n  }\n}\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n  return isArray(values) ? values.map((value, key) => getInnerPath(value, key)) : Object.entries(values).map(_ref10 => {\n    let [key, value] = _ref10;\n    return getInnerPath(value, key, true);\n  });\n};\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    value = fieldValues[fieldName];\n    watchFields.add(fieldName);\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\nvar skipValidation = _ref11 => {\n  let {\n    isOnChange,\n    hasError,\n    isBlurEvent,\n    isOnSubmit,\n    isReValidateOnSubmit,\n    isOnBlur,\n    isReValidateOnBlur,\n    isSubmitted\n  } = _ref11;\n  return isOnChange && isBlurEvent || isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n};\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\nvar getFieldValueByName = (fields, name) => {\n  const results = transformToNestObject(getFieldsValues(fields));\n  return name ? get(results, name, results) : results;\n};\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  let isMatch = false;\n  if (!isArray(referenceArray) || !isArray(differenceArray) || referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n  for (let i = 0; i < referenceArray.length; i++) {\n    if (isMatch) {\n      break;\n    }\n    const dataA = referenceArray[i];\n    const dataB = differenceArray[i];\n    if (isUndefined(dataB) || Object.keys(dataA).length !== Object.keys(dataB).length) {\n      isMatch = true;\n      break;\n    }\n    for (const key in dataA) {\n      if (dataA[key] !== dataB[key]) {\n        isMatch = true;\n        break;\n      }\n    }\n  }\n  return isMatch;\n}\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\nvar isSelectInput = element => element.type === `${SELECT}-one`;\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange\n});\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\nfunction useForm() {\n  let {\n    mode = VALIDATION_MODE.onSubmit,\n    reValidateMode = VALIDATION_MODE.onChange,\n    validationSchema,\n    validationResolver,\n    validationContext,\n    defaultValues = {},\n    submitFocusError = true,\n    validateCriteriaMode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const fieldArrayDefaultValues = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const dirtyFieldsRef = useRef(new Set());\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const resetFieldArrayFunctionRef = useRef({});\n  const validationContextRef = useRef(validationContext);\n  const fieldArrayNamesRef = useRef(new Set());\n  const [, render] = useState();\n  const {\n    isOnBlur,\n    isOnSubmit,\n    isOnChange\n  } = useRef(modeChecker(mode)).current;\n  const validateAllFieldCriteria = validateCriteriaMode === 'all';\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\n  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n  const readFormStateRef = useRef({\n    dirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnSubmit: isReValidateOnSubmit\n  } = useRef(modeChecker(reValidateMode)).current;\n  validationContextRef.current = validationContext;\n  const reRender = useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  const shouldRenderBaseOnError = useCallback(function (name, error) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || shouldValidateSchemaOrResolver) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || get(errorsRef.current, name);\n      }\n      errorsRef.current = unset(errorsRef.current, [name]);\n    } else {\n      const previousError = get(errorsRef.current, name);\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || (previousError ? !isSameError(previousError, error[name]) : true);\n      set(errorsRef.current, name, error[name]);\n    }\n    if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n      reRender();\n      return true;\n    }\n  }, [reRender, shouldValidateSchemaOrResolver]);\n  const setFieldValue = useCallback((field, rawValue) => {\n    const {\n      ref,\n      options\n    } = field;\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n    if (isRadioInput(ref) && options) {\n      options.forEach(_ref12 => {\n        let {\n          ref: radioRef\n        } = _ref12;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref)) {\n      if (isString(value)) {\n        ref.value = value;\n      } else {\n        ref.files = value;\n      }\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(_ref13 => {\n        let {\n          ref: checkboxRef\n        } = _ref13;\n        return checkboxRef.checked = value.includes(checkboxRef.value);\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, [isWeb]);\n  const setDirty = useCallback(name => {\n    if (!fieldsRef.current[name] || !readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields) {\n      return false;\n    }\n    let isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\n    if (isFieldArray) {\n      const fieldArrayName = getFieldArrayParentName(name);\n      isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\n    }\n    const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !== isFieldDirty;\n    if (isFieldDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n    isDirtyRef.current = isFieldArray ? isFieldDirty : !!dirtyFieldsRef.current.size;\n    return readFormStateRef.current.dirty ? isDirtyChanged : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\n  }, []);\n  const setInternalValues = useCallback((name, value, parentFieldName) => {\n    const isValueArray = isArray(value);\n    for (const key in value) {\n      const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\n      const field = fieldsRef.current[fieldName];\n      if (isObject(value[key])) {\n        setInternalValues(name, value[key], fieldName);\n      }\n      if (field) {\n        setFieldValue(field, value[key]);\n        setDirty(fieldName);\n      }\n    }\n  }, [setFieldValue, setDirty]);\n  const setInternalValue = useCallback((name, value) => {\n    const field = fieldsRef.current[name];\n    if (field) {\n      setFieldValue(field, value);\n      const output = setDirty(name);\n      if (isBoolean(output)) {\n        return output;\n      }\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value);\n    }\n  }, [setDirty, setFieldValue, setInternalValues]);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    const field = fieldsRef.current[name];\n    if (field) {\n      const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n      shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n      return isEmptyObject(error);\n    }\n    return false;\n  }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async payload => {\n    const {\n      errors\n    } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\n    const previousFormIsValid = isValidRef.current;\n    isValidRef.current = isEmptyObject(errors);\n    if (isArray(payload)) {\n      payload.forEach(name => {\n        const error = get(errors, name);\n        if (error) {\n          set(errorsRef.current, name, error);\n        } else {\n          unset(errorsRef.current, [name]);\n        }\n      });\n      reRender();\n    } else {\n      const error = get(errors, payload);\n      shouldRenderBaseOnError(payload, error ? {\n        [payload]: error\n      } : {}, previousFormIsValid !== isValidRef.current);\n    }\n    return isEmptyObject(errorsRef.current);\n  }, [reRender, shouldRenderBaseOnError, validateAllFieldCriteria, validationResolver, validationSchema]);\n  const triggerValidation = useCallback(async payload => {\n    const fields = payload || Object.keys(fieldsRef.current);\n    if (shouldValidateSchemaOrResolver) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, true)));\n      reRender();\n      return result.every(Boolean);\n    }\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation, reRender, shouldValidateSchemaOrResolver]);\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  function setValue(names, valueOrShouldValidate, shouldValidate) {\n    let shouldRender = false;\n    const isArrayValue = isArray(names);\n    (isArrayValue ? names : [names]).forEach(name => {\n      const isStringFieldName = isString(name);\n      shouldRender = setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName ? valueOrShouldValidate : Object.values(name)[0]) || isArrayValue ? true : isFieldWatched(name);\n    });\n    if (shouldRender || isArrayValue) {\n      reRender();\n    }\n    if (shouldValidate || isArrayValue && valueOrShouldValidate) {\n      triggerValidation(isArrayValue ? undefined : names);\n    }\n  }\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async _ref14 => {\n    let {\n      type,\n      target\n    } = _ref14;\n    const name = target ? target.name : '';\n    const fields = fieldsRef.current;\n    const errors = errorsRef.current;\n    const field = fields[name];\n    const currentError = get(errors, name);\n    let error;\n    if (!field) {\n      return;\n    }\n    const isBlurEvent = type === EVENTS.BLUR;\n    const shouldSkipValidation = skipValidation({\n      hasError: !!currentError,\n      isOnChange,\n      isBlurEvent,\n      isOnSubmit,\n      isReValidateOnSubmit,\n      isOnBlur,\n      isReValidateOnBlur,\n      isSubmitted: isSubmittedRef.current\n    });\n    const shouldUpdateDirty = setDirty(name);\n    let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\n    if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {\n      set(touchedFieldsRef.current, name, true);\n      shouldRender = true;\n    }\n    if (shouldSkipValidation) {\n      return shouldRender && reRender();\n    }\n    if (shouldValidateSchemaOrResolver) {\n      const {\n        errors\n      } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n      error = get(errors, name) ? {\n        [name]: get(errors, name)\n      } : {};\n      if (previousFormIsValid !== isValidRef.current) {\n        shouldRender = true;\n      }\n    } else {\n      error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n    }\n    if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n      reRender();\n    }\n  };\n  const validateSchemaOrResolver = useCallback(function () {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(_ref15 => {\n      let {\n        errors\n      } = _ref15;\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n      if (previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [reRender, validateAllFieldCriteria, validationResolver]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    if (handleChangeRef.current && field) {\n      findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\n    }\n  }, []);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (!field || field && isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) && !forceDelete) {\n      return;\n    }\n    removeFieldEventListener(field, forceDelete);\n    const {\n      name\n    } = field.ref;\n    errorsRef.current = unset(errorsRef.current, [name]);\n    touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\n    defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\n    [dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(data => data.current.delete(name));\n    if (readFormStateRef.current.isValid || readFormStateRef.current.touched) {\n      reRender();\n      if (shouldValidateSchemaOrResolver) {\n        validateSchemaOrResolver();\n      }\n    }\n  }, [reRender, shouldValidateSchemaOrResolver, validateSchemaOrResolver, removeFieldEventListener]);\n  function clearError(name) {\n    if (name) {\n      unset(errorsRef.current, isArray(name) ? name : [name]);\n    } else {\n      errorsRef.current = {};\n    }\n    reRender();\n  }\n  const setInternalError = _ref16 => {\n    let {\n      name,\n      type,\n      types,\n      message,\n      shouldRender\n    } = _ref16;\n    const field = fieldsRef.current[name];\n    if (!isSameError(get(errorsRef.current, name), {\n      type,\n      message,\n      types\n    })) {\n      set(errorsRef.current, name, {\n        type,\n        types,\n        message,\n        ref: field ? field.ref : {},\n        isManual: true\n      });\n      if (shouldRender) {\n        reRender();\n      }\n    }\n  };\n  function setError(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let message = arguments.length > 2 ? arguments[2] : undefined;\n    if (isString(name)) {\n      setInternalError(Object.assign(Object.assign({\n        name\n      }, isObject(type) ? {\n        types: type,\n        type: ''\n      } : {\n        type,\n        message\n      }), {\n        shouldRender: true\n      }));\n    } else if (isArray(name)) {\n      name.forEach(error => setInternalError(Object.assign({}, error)));\n      reRender();\n    }\n  }\n  function watch(fieldNames, defaultValue) {\n    const watchFields = watchFieldsRef.current;\n    const isDefaultValueUndefined = isUndefined(defaultValue);\n    const combinedDefaultValues = isDefaultValueUndefined ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n    isWatchAllRef.current = true;\n    const result = !isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues;\n    return fieldNames && fieldNames.nest ? transformToNestObject(result) : result;\n  }\n  function unregister(name) {\n    if (fieldsRef.current) {\n      (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n    }\n  }\n  function registerFieldsRef(ref) {\n    let validateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ref.name) {\n      // eslint-disable-next-line no-console\n      return console.warn('Missing name @', ref);\n    }\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n    if (isRadioOrCheckbox ? field && isArray(field.options) && field.options.filter(Boolean).find(option => {\n      return value === option.ref.value && option.ref === ref;\n    }) : field && ref === field.ref) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...(field && field.options || []), {\n          ref,\n          mutationWatcher\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), {\n        mutationWatcher\n      });\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n    fields[name] = field;\n    if (!isEmptyObject(defaultValuesRef.current)) {\n      defaultValue = get(defaultValuesRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n    if (shouldValidateSchemaOrResolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateSchemaOrResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, validateAllFieldCriteria, field).then(error => {\n          const previousFormIsValid = isValidRef.current;\n          isEmptyObject(error) ? validFieldsRef.current.add(name) : isValidRef.current = false;\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\n    }\n    if (type) {\n      attachEventListeners({\n        field: isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field,\n        isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\n        handleChange: handleChangeRef.current\n      });\n    }\n  }\n  function register(refOrValidationOptions, validationOptions) {\n    if (isWindowUndefined) {\n      return;\n    }\n    if (isString(refOrValidationOptions)) {\n      registerFieldsRef({\n        name: refOrValidationOptions\n      }, validationOptions);\n      return;\n    }\n    if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n      registerFieldsRef(refOrValidationOptions, validationOptions);\n      return;\n    }\n    return ref => ref && registerFieldsRef(ref, refOrValidationOptions);\n  }\n  const handleSubmit = useCallback(callback => async e => {\n    if (e) {\n      e.preventDefault();\n      e.persist();\n    }\n    let fieldErrors = {};\n    const fields = fieldsRef.current;\n    let fieldValues = getFieldsValues(fields);\n    if (readFormStateRef.current.isSubmitting) {\n      isSubmittingRef.current = true;\n      reRender();\n    }\n    try {\n      if (shouldValidateSchemaOrResolver) {\n        const {\n          errors,\n          values\n        } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\n        errorsRef.current = errors;\n        fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fields)) {\n          if (field) {\n            const {\n              ref: {\n                name\n              }\n            } = field;\n            const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              validFieldsRef.current.delete(name);\n            } else {\n              if (fieldsWithValidationRef.current.has(name)) {\n                validFieldsRef.current.add(name);\n              }\n            }\n          }\n        }\n      }\n      if (isEmptyObject(fieldErrors)) {\n        errorsRef.current = {};\n        reRender();\n        await callback(transformToNestObject(fieldValues), e);\n      } else {\n        errorsRef.current = fieldErrors;\n        if (submitFocusError && isWeb) {\n          focusOnErrorField(fields, fieldErrors);\n        }\n      }\n    } finally {\n      isSubmittedRef.current = true;\n      isSubmittingRef.current = false;\n      submitCountRef.current = submitCountRef.current + 1;\n      reRender();\n    }\n  }, [isWeb, reRender, shouldValidateSchemaOrResolver, submitFocusError, validateAllFieldCriteria, validationResolver, validationSchema]);\n  const resetRefs = _ref17 => {\n    let {\n      errors,\n      dirty,\n      isSubmitted,\n      touched,\n      isValid,\n      submitCount,\n      dirtyFields\n    } = _ref17;\n    fieldsRef.current = {};\n    if (!errors) {\n      errorsRef.current = {};\n    }\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n    if (!dirty) {\n      isDirtyRef.current = false;\n    }\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = new Set();\n    }\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValues.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n  const reset = function (values) {\n    let omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n    reRender();\n  };\n  function getValues(payload) {\n    if (isString(payload)) {\n      return fieldsRef.current[payload] ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref) : get(defaultValuesRef.current, payload);\n    }\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const outputValues = isEmptyObject(fieldValues) ? defaultValuesRef.current : fieldValues;\n    return payload && payload.nest ? transformToNestObject(outputValues) : outputValues;\n  }\n  useEffect(() => () => {\n    isUnMount.current = true;\n    fieldsRef.current && process.env.NODE_ENV === 'production' && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n  }, [removeFieldEventListenerAndRef]);\n  if (!shouldValidateSchemaOrResolver) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n  const formState = {\n    dirty: isDirtyRef.current,\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current\n  };\n  const commonProps = {\n    triggerValidation,\n    setValue: useCallback(setValue, [reRender, setInternalValue, triggerValidation]),\n    register: useCallback(register, [defaultValuesRef.current, defaultValuesAtRenderRef.current]),\n    unregister: useCallback(unregister, []),\n    getValues: useCallback(getValues, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = Object.assign(Object.assign(Object.assign({\n    removeFieldEventListener,\n    reRender\n  }, shouldValidateSchemaOrResolver ? {\n    validateSchemaIsValid: validateSchemaOrResolver\n  } : {}), {\n    mode: {\n      isOnBlur,\n      isOnSubmit,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    readFormStateRef,\n    defaultValuesRef\n  }), commonProps);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearError: useCallback(clearError, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current\n  }, commonProps);\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nconst FormGlobalContext = createContext(null);\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\nfunction FormContext(_a) {\n  var {\n      children,\n      formState,\n      errors\n    } = _a,\n    restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restMethods), {\n      formState,\n      errors\n    })\n  }, children);\n}\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, isObject(value) ? value : {\n  value\n});\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\nvar getSortRemovedItems = function (indexes, removeIndexes) {\n  let updatedIndexes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let notFoundIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  for (const removeIndex of removeIndexes) {\n    if (indexes.indexOf(removeIndex) < 0) {\n      notFoundIndexes.push(removeIndex);\n    }\n  }\n  for (const index of indexes.sort()) {\n    if (removeIndexes.indexOf(index) > -1) {\n      updatedIndexes.push(-1);\n      count++;\n    } else {\n      updatedIndexes.push(index - count - (notFoundIndexes.length ? notFoundIndexes.map(notFoundIndex => notFoundIndex < index).filter(Boolean).length : 0));\n    }\n  }\n  return updatedIndexes;\n};\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n  return data.filter(Boolean);\n}\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || null]), ...data];\n}\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || null]), ...data.slice(index)];\n}\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(null) : null;\nconst useFieldArray = _ref18 => {\n  let {\n    control,\n    name,\n    keyName = 'id'\n  } = _ref18;\n  const methods = useFormContext();\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    reRender,\n    fieldsRef,\n    getValues,\n    defaultValuesRef,\n    removeFieldEventListener,\n    errorsRef,\n    dirtyFieldsRef,\n    isDirtyRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValues,\n    validateSchemaIsValid\n  } = control || methods.control;\n  const getDefaultValues = () => [...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)] ? fieldArrayDefaultValues.current : defaultValuesRef.current, name, [])];\n  const memoizedDefaultValues = useRef(getDefaultValues());\n  const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  const [isDeleted, setIsDeleted] = useState(false);\n  const allFields = useRef(fields);\n  const isNameKey = isKey(name);\n  allFields.current = fields;\n  if (isNameKey) {\n    fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\n  }\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n  const setFieldAndValidState = fieldsValues => {\n    setField(fieldsValues);\n    if (readFormStateRef.current.isValid && validateSchemaIsValid) {\n      validateSchemaIsValid({\n        [name]: fieldsValues\n      });\n    }\n  };\n  const modifyDirtyFields = function () {\n    let {\n      shouldRender,\n      isRemove,\n      isPrePend,\n      index,\n      value = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let render = shouldRender;\n    const values = isArray(value) ? value : [value];\n    if (readFormStateRef.current.dirty) {\n      const dirtyFieldIndexesAndValues = {};\n      if (isPrePend || isRemove) {\n        for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\n          if (isMatchFieldArrayName(dirtyField, name)) {\n            const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\n            if (matchedIndexes) {\n              const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\n              if (dirtyFieldIndexesAndValues[matchIndex]) {\n                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\n              } else {\n                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\n              }\n            }\n            dirtyFieldsRef.current.delete(dirtyField);\n          }\n        }\n      }\n      if (!isUndefined(index) || isPrePend) {\n        const updatedDirtyFieldIndexes = isUndefined(index) ? [] : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map(i => +i), isArray(index) ? index : [index]);\n        Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\n          const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\n          if (updateIndex > -1) {\n            for (const value of values) {\n              const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\n              if (matchedIndexes) {\n                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend ? +matchedIndexes[matchedIndexes.length - 1] + values.length : updateIndex}$1`));\n              }\n            }\n          }\n        });\n      }\n      if (!isRemove) {\n        values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach(key => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\n        isDirtyRef.current = true;\n      }\n      render = true;\n    }\n    if (render && !isWatchAllRef.current) {\n      reRender();\n    }\n  };\n  const resetFields = flagOrFields => {\n    if (readFormStateRef.current.dirty) {\n      isDirtyRef.current = isUndefined(flagOrFields) ? true : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\n    }\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n  const mapCurrentFieldsValueWithState = () => {\n    const currentFieldsValue = get(getValues({\n      nest: true\n    }), name);\n    if (isArray(currentFieldsValue)) {\n      for (let i = 0; i < currentFieldsValue.length; i++) {\n        allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\n      }\n    }\n  };\n  const append = value => {\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n    modifyDirtyFields({\n      value\n    });\n  };\n  const prepend$1 = value => {\n    let shouldRender = false;\n    resetFields();\n    setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\n      shouldRender = true;\n    }\n    modifyDirtyFields({\n      shouldRender,\n      isPrePend: true,\n      value\n    });\n  };\n  const remove = index => {\n    let shouldRender = false;\n    const isIndexUndefined = isUndefined(index);\n    if (!isIndexUndefined) {\n      mapCurrentFieldsValueWithState();\n    }\n    resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(removeArrayAt(allFields.current, index));\n    setIsDeleted(true);\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\n      if (!errorsRef.current[name].filter(Boolean).length) {\n        delete errorsRef.current[name];\n      }\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\n      shouldRender = true;\n    }\n    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n        if (!isFound) {\n          continue;\n        }\n        for (const key in fields[fieldIndex]) {\n          const currentFieldName = `${name}[${fieldIndex}].${key}`;\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(currentFieldName);\n            fieldsWithValidationRef.current.delete(currentFieldName);\n          } else {\n            const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\n            if (validFieldsRef.current.has(currentFieldName)) {\n              validFieldsRef.current.add(previousFieldName);\n            }\n            if (fieldsWithValidationRef.current.has(currentFieldName)) {\n              fieldsWithValidationRef.current.add(previousFieldName);\n            }\n          }\n        }\n      }\n    }\n    modifyDirtyFields({\n      shouldRender,\n      isRemove: true,\n      index\n    });\n  };\n  const insert$1 = (index, value) => {\n    mapCurrentFieldsValueWithState();\n    resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\n      reRender();\n    }\n  };\n  const swap = (indexA, indexB) => {\n    mapCurrentFieldsValueWithState();\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    swapArrayAt(allFields.current, indexA, indexB);\n    setFieldAndValidState([...allFields.current]);\n    if (errorsRef.current[name]) {\n      swapArrayAt(errorsRef.current[name], indexA, indexB);\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\n      reRender();\n    }\n  };\n  const move = (from, to) => {\n    mapCurrentFieldsValueWithState();\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    moveArrayAt(allFields.current, from, to);\n    setFieldAndValidState([...allFields.current]);\n    if (errorsRef.current[name]) {\n      moveArrayAt(errorsRef.current[name], from, to);\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      moveArrayAt(touchedFieldsRef.current[name], from, to);\n      reRender();\n    }\n  };\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setField(mapIds(memoizedDefaultValues.current, keyName));\n  };\n  useEffect(() => {\n    if (isNameKey && isDeleted && fieldArrayDefaultValues.current[name] && fields.length < fieldArrayDefaultValues.current[name].length) {\n      fieldArrayDefaultValues.current[name].pop();\n    }\n  }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\n  useEffect(() => {\n    if (isWatchAllRef && isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          reRender();\n          break;\n        }\n      }\n    }\n  }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [fields, name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isCheckboxInput || isUndefined(event.target.value) ? event.target.checked : event.target.value;\nconst Controller = _a => {\n  var {\n      name,\n      rules,\n      as: InnerComponent,\n      onBlur,\n      onChange,\n      onChangeName = VALIDATION_MODE.onChange,\n      onBlurName = VALIDATION_MODE.onBlur,\n      valueName,\n      defaultValue,\n      control,\n      onFocus\n    } = _a,\n    rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\n  const methods = useFormContext();\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    errorsRef,\n    removeFieldEventListener,\n    triggerValidation,\n    mode: {\n      isOnSubmit,\n      isOnBlur,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    formState: {\n      isSubmitted\n    },\n    touchedFieldsRef,\n    readFormStateRef,\n    reRender,\n    fieldsRef,\n    fieldArrayNamesRef\n  } = control || methods.control;\n  const [value, setInputStateValue] = useState(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);\n  const valueRef = useRef(value);\n  const isCheckboxInput = isBoolean(value);\n  const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\n  const rulesRef = useRef(rules);\n  const onFocusRef = useRef(onFocus);\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  rulesRef.current = rules;\n  const shouldValidate = () => !skipValidation({\n    hasError: !!get(errorsRef.current, name),\n    isOnBlur,\n    isOnSubmit,\n    isOnChange,\n    isReValidateOnBlur,\n    isReValidateOnSubmit,\n    isSubmitted\n  });\n  const commonTask = event => {\n    const data = getInputValue(event, isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n  const eventWrapper = event => function () {\n    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n      arg[_key] = arguments[_key];\n    }\n    return setValue(name, commonTask(event(arg)), shouldValidate());\n  };\n  const handleChange = event => {\n    const data = commonTask(event);\n    setValue(name, data, shouldValidate());\n  };\n  const registerField = useCallback(() => {\n    if (!isNotFieldArray) {\n      removeFieldEventListener(fieldsRef.current[name], true);\n    }\n    register(Object.defineProperty({\n      name,\n      focus: onFocusRef.current\n    }, VALUE, {\n      set(data) {\n        setInputStateValue(data);\n        valueRef.current = data;\n      },\n      get() {\n        return valueRef.current;\n      }\n    }), rulesRef.current);\n  }, [isNotFieldArray, fieldsRef, rulesRef, name, onFocusRef, register, removeFieldEventListener]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);\n      }\n    }\n  });\n  const props = Object.assign(Object.assign(Object.assign(Object.assign({\n    name\n  }, rest), onChange ? {\n    [onChangeName]: eventWrapper(onChange)\n  } : {\n    [onChangeName]: handleChange\n  }), {\n    [onBlurName]: function () {\n      if (onBlur) {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        onBlur(args);\n      }\n      if (readFormStateRef.current.touched && !get(touchedFieldsRef.current, name)) {\n        set(touchedFieldsRef.current, name, true);\n        reRender();\n      }\n      if (shouldReValidateOnBlur) {\n        triggerValidation(name);\n      }\n    }\n  }), {\n    [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value\n  });\n  return isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, props);\n};\nconst ErrorMessage = _a => {\n  var {\n      as: InnerComponent,\n      errors,\n      name,\n      message,\n      children\n    } = _a,\n    rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\n  const methods = useFormContext();\n  const error = get(errors || methods.errors, name);\n  if (!error) {\n    return null;\n  }\n  const {\n    message: messageFromRegister,\n    types\n  } = error;\n  const props = Object.assign(Object.assign({}, InnerComponent ? rest : {}), {\n    children: children ? children({\n      message: messageFromRegister || message,\n      messages: types\n    }) : messageFromRegister || message\n  });\n  return InnerComponent ? isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, props) : createElement(Fragment, Object.assign({}, props));\n};\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };","map":{"version":3,"names":["isValidElement","useRef","useState","useCallback","useEffect","createContext","useContext","createElement","cloneElement","Fragment","isNullOrUndefined","value","isArray","Array","isObjectType","isObject","isHTMLElement","nodeType","Node","ELEMENT_NODE","VALIDATION_MODE","onBlur","onChange","onSubmit","VALUE","UNDEFINED","EVENTS","BLUR","CHANGE","INPUT","SELECT","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","REGEX_IS_DEEP_PROP","REGEX_IS_PLAIN_PROP","REGEX_PROP_NAME","REGEX_ESCAPE_CHAR","REGEX_ARRAY_FIELD_INDEX","attachEventListeners","field","ref","handleChange","isRadioOrCheckbox","addEventListener","isKey","test","stringToPath","string","result","replace","match","number","quote","push","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","Object","entries","reduce","previous","assign","isUndefined","val","undefined","get","obj","defaultValue","split","filter","Boolean","focusOnErrorField","fields","fieldErrors","focus","options","removeAllEventListeners","validateWithStateUpdate","removeEventListener","isRadioInput","element","type","isCheckBoxInput","isDetached","HTMLElement","DOCUMENT_NODE","parentNode","isEmptyObject","keys","castPath","baseGet","updatePath","baseSlice","array","start","end","parent","baseUnset","childObject","previousObjRef","k","slice","objectRef","currentPaths","currentPathsLength","item","unset","paths","forEach","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","forceDelete","name","mutationWatcher","option","disconnect","defaultReturn","isValid","getRadioValue","checked","getMultipleSelectValue","selected","map","isFileInput","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","values","attributes","getFieldValue","files","isString","getFieldsValues","search","output","startsWith","find","nest","compareObject","objectA","objectB","objectAKeys","objectBKeys","every","isSameError","error","types","message","shouldRenderBasedOnError","errors","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","isRegex","RegExp","getValueAndMessage","validationData","isValueMessage","isFunction","isBoolean","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","validateField","fieldsRef","_a","current","isRadio","isCheckBox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","requiredValue","requiredMessage","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","valueAsNumber","parseFloat","valueDate","valueAsDate","Date","maxLengthValue","minLengthValue","inputLength","toString","patternValue","patternMessage","validateRef","validateError","validationResult","validateFunction","validateResult","parseErrorSchema","inner","validateWithSchema","validationSchema","validationResolver","context","abortEarly","e","isPrimitive","getPath","getInnerPath","pathWithIndex","getPath$1","parentPath","flat","Infinity","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","skipValidation","isOnChange","hasError","isBlurEvent","isOnSubmit","isReValidateOnSubmit","isOnBlur","isReValidateOnBlur","isSubmitted","getFieldArrayParentName","substring","indexOf","getFieldValueByName","results","getIsFieldsDifferent","referenceArray","differenceArray","isMatch","i","dataA","dataB","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isSelectInput","onDomRemove","onDetachCallback","observer","MutationObserver","observe","window","document","childList","subtree","modeChecker","mode","isRadioOrCheckboxFunction","useForm","reValidateMode","validationContext","defaultValues","submitFocusError","validateCriteriaMode","errorsRef","touchedFieldsRef","fieldArrayDefaultValues","watchFieldsRef","Set","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","handleChangeRef","resetFieldArrayFunctionRef","validationContextRef","fieldArrayNamesRef","render","isWindowUndefined","shouldValidateSchemaOrResolver","isWeb","isProxyEnabled","Proxy","readFormStateRef","dirty","dirtyFields","submitCount","touched","isSubmitting","reRender","shouldRenderBaseOnError","shouldRender","shouldReRender","previousError","delete","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","setDirty","isFieldDirty","isFieldArray","previousDirtyFieldsLength","size","fieldArrayName","isDirtyChanged","setInternalValues","parentFieldName","isValueArray","setInternalValue","executeValidation","skipReRender","executeSchemaOrResolverValidation","payload","previousFormIsValid","triggerValidation","Promise","all","isFieldWatched","setValue","valueOrShouldValidate","shouldValidate","isArrayValue","isStringFieldName","target","currentError","shouldSkipValidation","shouldUpdateDirty","validateSchemaOrResolver","then","removeFieldEventListener","removeFieldEventListenerAndRef","clearError","setInternalError","setError","watch","fieldNames","isDefaultValueUndefined","combinedDefaultValues","unregister","registerFieldsRef","validateOptions","console","warn","fieldRefAndValidationOptions","isEmptyDefaultValue","register","refOrValidationOptions","validationOptions","handleSubmit","callback","preventDefault","persist","fieldError","resetRefs","reset","omitResetState","inputRef","closest","resetFieldArray","getValues","outputValues","process","env","NODE_ENV","formState","commonProps","prop","control","validateSchemaIsValid","__rest","s","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","propertyIsEnumerable","FormGlobalContext","useFormContext","FormContext","children","restMethods","Provider","generateId","d","performance","now","c","r","Math","random","appendId","keyName","mapIds","getSortRemovedItems","indexes","removeIndexes","updatedIndexes","count","notFoundIndexes","removeIndex","sort","notFoundIndex","removeAt","removeAtIndexes","removeArrayAt","moveArrayAt","from","to","splice","swapArrayAt","indexA","indexB","temp","prepend","insert","fillEmptyArray","fill","useFieldArray","methods","getDefaultValues","memoizedDefaultValues","setField","isDeleted","setIsDeleted","allFields","isNameKey","appendValueWithKey","setFieldAndValidState","fieldsValues","modifyDirtyFields","isRemove","isPrePend","dirtyFieldIndexesAndValues","dirtyField","matchedIndexes","matchIndex","updatedDirtyFieldIndexes","updateIndex","resetFields","flagOrFields","mapCurrentFieldsValueWithState","currentFieldsValue","append","prepend$1","remove","isIndexUndefined","fieldIndex","isFound","isLast","isCurrentIndex","currentFieldName","previousFieldName","insert$1","swap","move","pop","watchField","resetFunctions","fieldArrayNames","getInputValue","event","isCheckboxInput","Controller","rules","as","InnerComponent","onChangeName","onBlurName","valueName","onFocus","rest","setInputStateValue","valueRef","shouldReValidateOnBlur","rulesRef","onFocusRef","isNotFieldArray","commonTask","eventWrapper","arg","registerField","defineProperty","props","args","ErrorMessage","messageFromRegister","messages"],"sources":["/home/rifat/uk client/garage/garage-frontend-2/theme/node_modules/react-hook-form/dist/react-hook-form.es.js"],"sourcesContent":["import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst SELECT = 'select';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef({});\r\n    const fieldArrayDefaultValues = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidRef = useRef(true);\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const validationContextRef = useRef(validationContext);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = useRef(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = useRef({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            const previousError = get(errorsRef.current, name);\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    (previousError\r\n                        ? !isSameError(previousError, error[name])\r\n                        : true);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = useCallback((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = useCallback((name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    }, []);\r\n    const setInternalValues = useCallback((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirty(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirty]);\r\n    const setInternalValue = useCallback((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirty(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = useCallback(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = useCallback((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(get(errorsRef.current, name), {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            process.env.NODE_ENV === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: useCallback(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: useCallback(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: useCallback(unregister, []),\r\n        getValues: useCallback(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearError: useCallback(clearError, []), setError: useCallback(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = useRef(getDefaultValues());\r\n    const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = useState(false);\r\n    const allFields = useRef(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    useEffect(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    useEffect(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [fields, name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = useState(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = useRef(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = useRef(rules);\r\n    const onFocusRef = useRef(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = useCallback(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    useEffect(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    useEffect(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    useEffect(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {\r\n            if (onBlur) {\r\n                onBlur(args);\r\n            }\r\n            if (readFormStateRef.current.touched &&\r\n                !get(touchedFieldsRef.current, name)) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                reRender();\r\n            }\r\n            if (shouldReValidateOnBlur) {\r\n                triggerValidation(name);\r\n            }\r\n        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return isValidElement(InnerComponent)\r\n        ? cloneElement(InnerComponent, props)\r\n        : createElement(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (isValidElement(InnerComponent) ? (cloneElement(InnerComponent, props)) : (createElement(InnerComponent, props))) : (createElement(Fragment, Object.assign({}, props)));\r\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}