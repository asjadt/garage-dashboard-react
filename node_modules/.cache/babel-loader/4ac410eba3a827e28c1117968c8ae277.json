{"ast":null,"code":"'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\nfunction dragula(initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) {\n    o.moves = always;\n  }\n  if (o.accepts === void 0) {\n    o.accepts = always;\n  }\n  if (o.invalid === void 0) {\n    o.invalid = invalidTarget;\n  }\n  if (o.containers === void 0) {\n    o.containers = initialContainers || [];\n  }\n  if (o.isContainer === void 0) {\n    o.isContainer = never;\n  }\n  if (o.copy === void 0) {\n    o.copy = false;\n  }\n  if (o.copySortSource === void 0) {\n    o.copySortSource = false;\n  }\n  if (o.revertOnSpill === void 0) {\n    o.revertOnSpill = false;\n  }\n  if (o.removeOnSpill === void 0) {\n    o.removeOnSpill = false;\n  }\n  if (o.direction === void 0) {\n    o.direction = 'vertical';\n  }\n  if (o.ignoreInputTextSelection === void 0) {\n    o.ignoreInputTextSelection = true;\n  }\n  if (o.mirrorContainer === void 0) {\n    o.mirrorContainer = doc.body;\n  }\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n  events();\n  return drake;\n  function isContainer(el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n  function events(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n  function eventualMovements(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n  function movements(remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n  function destroy() {\n    events(true);\n    release({});\n  }\n  function preventGrabbed(e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n  function grab(e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) {\n        // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved(e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n    // truthy check fixes #239, equality fixes #207\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n  function canStart(item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n    return {\n      item: item,\n      source: source\n    };\n  }\n  function canMove(item) {\n    return !!canStart(item);\n  }\n  function manualStart(item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n  function start(context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n  function invalidTarget() {\n    return false;\n  }\n  function end() {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n  function ungrab() {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n  function release(e) {\n    ungrab();\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n  function drop(item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n  function remove() {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n  function cancel(revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n  function cleanup() {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n  function isInitialPlacement(target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n  function findDropTarget(elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n    function accepted() {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n  function drag(e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (reference === null && changed || reference !== item && reference !== nextEl(item)) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved(type) {\n      drake.emit(type, item, _lastDropTarget, _source);\n    }\n    function over() {\n      if (changed) {\n        moved('over');\n      }\n    }\n    function out() {\n      if (_lastDropTarget) {\n        moved('out');\n      }\n    }\n  }\n  function spillOver(el) {\n    classes.rm(el, 'gu-hide');\n  }\n  function spillOut(el) {\n    if (drake.dragging) {\n      classes.add(el, 'gu-hide');\n    }\n  }\n  function renderMirrorImage() {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n  function removeMirrorImage() {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n  function getImmediateChild(dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n  function getReference(dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n    function outside() {\n      // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && rect.left + rect.width / 2 > x) {\n          return el;\n        }\n        if (!horizontal && rect.top + rect.height / 2 > y) {\n          return el;\n        }\n      }\n      return null;\n    }\n    function inside() {\n      // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n  function isCopy(item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\nfunction touchy(el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\nfunction whichMouseButton(e) {\n  if (e.touches !== void 0) {\n    return e.touches.length;\n  }\n  if (e.which !== void 0 && e.which !== 0) {\n    return e.which;\n  } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) {\n    return e.buttons;\n  }\n  var button = e.button;\n  if (button !== void 0) {\n    // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n}\nfunction getOffset(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\nfunction getElementBehindPoint(point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\nfunction never() {\n  return false;\n}\nfunction always() {\n  return true;\n}\nfunction getRectWidth(rect) {\n  return rect.width || rect.right - rect.left;\n}\nfunction getRectHeight(rect) {\n  return rect.height || rect.bottom - rect.top;\n}\nfunction getParent(el) {\n  return el.parentNode === doc ? null : el.parentNode;\n}\nfunction isInput(el) {\n  return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n}\nfunction isEditable(el) {\n  if (!el) {\n    return false;\n  } // no parents were editable\n  if (el.contentEditable === 'false') {\n    return false;\n  } // stop the lookup\n  if (el.contentEditable === 'true') {\n    return true;\n  } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl(el) {\n  return el.nextElementSibling || manually();\n  function manually() {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\nfunction getCoord(coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX',\n    // IE8\n    pageY: 'clientY' // IE8\n  };\n\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\nmodule.exports = dragula;","map":{"version":3,"names":["emitter","require","crossvent","classes","doc","document","documentElement","dragula","initialContainers","options","len","arguments","length","Array","isArray","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","_lastDropTarget","_grabbed","o","moves","always","accepts","invalid","invalidTarget","containers","isContainer","never","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","body","drake","start","manualStart","end","cancel","remove","destroy","canMove","dragging","on","spillOver","spillOut","events","el","indexOf","op","touchy","grab","release","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","e","preventDefault","clientX","clientY","ignore","whichMouseButton","metaKey","ctrlKey","item","target","context","canStart","type","isInput","focus","getCoord","elementBehindCursor","elementFromPoint","grabbed","offset","getOffset","left","top","add","renderMirrorImage","drag","handle","getParent","source","movable","nextEl","isCopy","cloneNode","emit","drop","ungrab","getElementBehindPoint","dropTarget","findDropTarget","parent","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","removeMirrorImage","rm","clearTimeout","s","sibling","accepted","droppable","immediate","getImmediateChild","reference","getReference","x","y","style","changed","out","over","moved","rect","getBoundingClientRect","width","getRectWidth","height","getRectHeight","appendChild","horizontal","inside","outside","children","i","resolve","after","container","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","global","navigator","pointerEnabled","msPointerEnabled","touches","which","buttons","button","getScroll","scrollProp","offsetProp","clientHeight","point","p","state","className","right","bottom","parentNode","tagName","isEditable","contentEditable","nextElementSibling","manually","nextSibling","nodeType","getEventHost","targetTouches","changedTouches","coord","host","missMap","pageX","pageY","module","exports"],"sources":["/home/rifat/uk client/garage/garage-frontend-2/theme/node_modules/dragula/dragula.js"],"sourcesContent":["'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n    // truthy check fixes #239, equality fixes #207\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}