{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _desc, _value, _class;\nvar _react = require('react');\nvar _react2 = _interopRequireDefault(_react);\nvar _propTypes = require('prop-types');\nvar _propTypes2 = _interopRequireDefault(_propTypes);\nvar _autobindDecorator = require('autobind-decorator');\nvar _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);\nvar _valueTransformer = require('./value-transformer');\nvar valueTransformer = _interopRequireWildcard(_valueTransformer);\nvar _defaultClassNames = require('./default-class-names');\nvar _defaultClassNames2 = _interopRequireDefault(_defaultClassNames);\nvar _label = require('./label');\nvar _label2 = _interopRequireDefault(_label);\nvar _rangePropType = require('./range-prop-type');\nvar _rangePropType2 = _interopRequireDefault(_rangePropType);\nvar _valuePropType = require('./value-prop-type');\nvar _valuePropType2 = _interopRequireDefault(_valuePropType);\nvar _slider = require('./slider');\nvar _slider2 = _interopRequireDefault(_slider);\nvar _track = require('./track');\nvar _track2 = _interopRequireDefault(_track);\nvar _utils = require('../utils');\nvar _keyCodes = require('./key-codes');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n  return desc;\n}\n\n/**\n * A React component that allows users to input numeric values within a range\n * by dragging its sliders.\n */\nvar InputRange = (_class = function (_React$Component) {\n  _inherits(InputRange, _React$Component);\n  _createClass(InputRange, null, [{\n    key: 'propTypes',\n    /**\n     * @ignore\n     * @override\n     * @return {Object}\n     */\n    get: function get() {\n      return {\n        allowSameValues: _propTypes2.default.bool,\n        ariaLabelledby: _propTypes2.default.string,\n        ariaControls: _propTypes2.default.string,\n        classNames: _propTypes2.default.objectOf(_propTypes2.default.string),\n        disabled: _propTypes2.default.bool,\n        draggableTrack: _propTypes2.default.bool,\n        formatLabel: _propTypes2.default.func,\n        maxValue: _rangePropType2.default,\n        minValue: _rangePropType2.default,\n        name: _propTypes2.default.string,\n        onChangeStart: _propTypes2.default.func,\n        onChange: _propTypes2.default.func.isRequired,\n        onChangeComplete: _propTypes2.default.func,\n        step: _propTypes2.default.number,\n        value: _valuePropType2.default\n      };\n    }\n\n    /**\n     * @ignore\n     * @override\n     * @return {Object}\n     */\n  }, {\n    key: 'defaultProps',\n    get: function get() {\n      return {\n        allowSameValues: false,\n        classNames: _defaultClassNames2.default,\n        disabled: false,\n        maxValue: 10,\n        minValue: 0,\n        step: 1\n      };\n    }\n\n    /**\n     * @param {Object} props\n     * @param {boolean} [props.allowSameValues]\n     * @param {string} [props.ariaLabelledby]\n     * @param {string} [props.ariaControls]\n     * @param {InputRangeClassNames} [props.classNames]\n     * @param {boolean} [props.disabled = false]\n     * @param {Function} [props.formatLabel]\n     * @param {number|Range} [props.maxValue = 10]\n     * @param {number|Range} [props.minValue = 0]\n     * @param {string} [props.name]\n     * @param {string} props.onChange\n     * @param {Function} [props.onChangeComplete]\n     * @param {Function} [props.onChangeStart]\n     * @param {number} [props.step = 1]\n     * @param {number|Range} props.value\n     */\n  }]);\n\n  function InputRange(props) {\n    _classCallCheck(this, InputRange);\n\n    /**\n     * @private\n     * @type {?number}\n     */\n    var _this = _possibleConstructorReturn(this, (InputRange.__proto__ || Object.getPrototypeOf(InputRange)).call(this, props));\n    _this.startValue = null;\n\n    /**\n     * @private\n     * @type {?Component}\n     */\n    _this.node = null;\n\n    /**\n     * @private\n     * @type {?Component}\n     */\n    _this.trackNode = null;\n\n    /**\n     * @private\n     * @type {bool}\n     */\n    _this.isSliderDragging = false;\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    _this.lastKeyMoved = null;\n    return _this;\n  }\n\n  /**\n   * @ignore\n   * @override\n   * @return {void}\n   */\n\n  _createClass(InputRange, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.removeDocumentMouseUpListener();\n      this.removeDocumentTouchEndListener();\n    }\n\n    /**\n     * Return the CSS class name of the component\n     * @private\n     * @return {string}\n     */\n  }, {\n    key: 'getComponentClassName',\n    value: function getComponentClassName() {\n      if (!this.props.disabled) {\n        return this.props.classNames.inputRange;\n      }\n      return this.props.classNames.disabledInputRange;\n    }\n\n    /**\n     * Return the bounding rect of the track\n     * @private\n     * @return {ClientRect}\n     */\n  }, {\n    key: 'getTrackClientRect',\n    value: function getTrackClientRect() {\n      return this.trackNode.getClientRect();\n    }\n\n    /**\n     * Return the slider key closest to a point\n     * @private\n     * @param {Point} position\n     * @return {string}\n     */\n  }, {\n    key: 'getKeyByPosition',\n    value: function getKeyByPosition(position) {\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());\n      if (this.isMultiValue()) {\n        var distanceToMin = (0, _utils.distanceTo)(position, positions.min);\n        var distanceToMax = (0, _utils.distanceTo)(position, positions.max);\n        if (distanceToMin < distanceToMax) {\n          return 'min';\n        }\n      }\n      return 'max';\n    }\n\n    /**\n     * Return all the slider keys\n     * @private\n     * @return {string[]}\n     */\n  }, {\n    key: 'getKeys',\n    value: function getKeys() {\n      if (this.isMultiValue()) {\n        return ['min', 'max'];\n      }\n      return ['max'];\n    }\n\n    /**\n     * Return true if the difference between the new and the current value is\n     * greater or equal to the step amount of the component\n     * @private\n     * @param {Range} values\n     * @return {boolean}\n     */\n  }, {\n    key: 'hasStepDifference',\n    value: function hasStepDifference(values) {\n      var currentValues = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      return (0, _utils.length)(values.min, currentValues.min) >= this.props.step || (0, _utils.length)(values.max, currentValues.max) >= this.props.step;\n    }\n\n    /**\n     * Return true if the component accepts a min and max value\n     * @private\n     * @return {boolean}\n     */\n  }, {\n    key: 'isMultiValue',\n    value: function isMultiValue() {\n      return (0, _utils.isObject)(this.props.value);\n    }\n\n    /**\n     * Return true if the range is within the max and min value of the component\n     * @private\n     * @param {Range} values\n     * @return {boolean}\n     */\n  }, {\n    key: 'isWithinRange',\n    value: function isWithinRange(values) {\n      if (this.isMultiValue()) {\n        return values.min >= this.props.minValue && values.max <= this.props.maxValue && this.props.allowSameValues ? values.min <= values.max : values.min < values.max;\n      }\n      return values.max >= this.props.minValue && values.max <= this.props.maxValue;\n    }\n\n    /**\n     * Return true if the new value should trigger a render\n     * @private\n     * @param {Range} values\n     * @return {boolean}\n     */\n  }, {\n    key: 'shouldUpdate',\n    value: function shouldUpdate(values) {\n      return this.isWithinRange(values) && this.hasStepDifference(values);\n    }\n\n    /**\n     * Update the position of a slider\n     * @private\n     * @param {string} key\n     * @param {Point} position\n     * @return {void}\n     */\n  }, {\n    key: 'updatePosition',\n    value: function updatePosition(key, position) {\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());\n      positions[key] = position;\n      this.lastKeyMoved = key;\n      this.updatePositions(positions);\n    }\n\n    /**\n     * Update the positions of multiple sliders\n     * @private\n     * @param {Object} positions\n     * @param {Point} positions.min\n     * @param {Point} positions.max\n     * @return {void}\n     */\n  }, {\n    key: 'updatePositions',\n    value: function updatePositions(positions) {\n      var values = {\n        min: valueTransformer.getValueFromPosition(positions.min, this.props.minValue, this.props.maxValue, this.getTrackClientRect()),\n        max: valueTransformer.getValueFromPosition(positions.max, this.props.minValue, this.props.maxValue, this.getTrackClientRect())\n      };\n      var transformedValues = {\n        min: valueTransformer.getStepValueFromValue(values.min, this.props.step),\n        max: valueTransformer.getStepValueFromValue(values.max, this.props.step)\n      };\n      this.updateValues(transformedValues);\n    }\n\n    /**\n     * Update the value of a slider\n     * @private\n     * @param {string} key\n     * @param {number} value\n     * @return {void}\n     */\n  }, {\n    key: 'updateValue',\n    value: function updateValue(key, value) {\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      values[key] = value;\n      this.updateValues(values);\n    }\n\n    /**\n     * Update the values of multiple sliders\n     * @private\n     * @param {Range|number} values\n     * @return {void}\n     */\n  }, {\n    key: 'updateValues',\n    value: function updateValues(values) {\n      if (!this.shouldUpdate(values)) {\n        return;\n      }\n      this.props.onChange(this.isMultiValue() ? values : values.max);\n    }\n\n    /**\n     * Increment the value of a slider by key name\n     * @private\n     * @param {string} key\n     * @return {void}\n     */\n  }, {\n    key: 'incrementValue',\n    value: function incrementValue(key) {\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var value = values[key] + this.props.step;\n      this.updateValue(key, value);\n    }\n\n    /**\n     * Decrement the value of a slider by key name\n     * @private\n     * @param {string} key\n     * @return {void}\n     */\n  }, {\n    key: 'decrementValue',\n    value: function decrementValue(key) {\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var value = values[key] - this.props.step;\n      this.updateValue(key, value);\n    }\n\n    /**\n     * Listen to mouseup event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'addDocumentMouseUpListener',\n    value: function addDocumentMouseUpListener() {\n      this.removeDocumentMouseUpListener();\n      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);\n    }\n\n    /**\n     * Listen to touchend event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'addDocumentTouchEndListener',\n    value: function addDocumentTouchEndListener() {\n      this.removeDocumentTouchEndListener();\n      this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);\n    }\n\n    /**\n     * Stop listening to mouseup event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'removeDocumentMouseUpListener',\n    value: function removeDocumentMouseUpListener() {\n      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);\n    }\n\n    /**\n     * Stop listening to touchend event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'removeDocumentTouchEndListener',\n    value: function removeDocumentTouchEndListener() {\n      this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);\n    }\n\n    /**\n     * Handle any \"mousemove\" event received by the slider\n     * @private\n     * @param {SyntheticEvent} event\n     * @param {string} key\n     * @return {void}\n     */\n  }, {\n    key: 'handleSliderDrag',\n    value: function handleSliderDrag(event, key) {\n      var _this2 = this;\n      if (this.props.disabled) {\n        return;\n      }\n      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());\n      this.isSliderDragging = true;\n      requestAnimationFrame(function () {\n        return _this2.updatePosition(key, position);\n      });\n    }\n\n    /**\n     * Handle any \"mousemove\" event received by the track\n     * @private\n     * @param {SyntheticEvent} event\n     * @return {void}\n     */\n  }, {\n    key: 'handleTrackDrag',\n    value: function handleTrackDrag(event, prevEvent) {\n      if (this.props.disabled || !this.props.draggableTrack || this.isSliderDragging) {\n        return;\n      }\n      var _props = this.props,\n        maxValue = _props.maxValue,\n        minValue = _props.minValue,\n        _props$value = _props.value,\n        max = _props$value.max,\n        min = _props$value.min;\n      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());\n      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());\n      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);\n      var prevPosition = valueTransformer.getPositionFromEvent(prevEvent, this.getTrackClientRect());\n      var prevValue = valueTransformer.getValueFromPosition(prevPosition, minValue, maxValue, this.getTrackClientRect());\n      var prevStepValue = valueTransformer.getStepValueFromValue(prevValue, this.props.step);\n      var offset = prevStepValue - stepValue;\n      var transformedValues = {\n        min: min - offset,\n        max: max - offset\n      };\n      this.updateValues(transformedValues);\n    }\n\n    /**\n     * Handle any \"keydown\" event received by the slider\n     * @private\n     * @param {SyntheticEvent} event\n     * @param {string} key\n     * @return {void}\n     */\n  }, {\n    key: 'handleSliderKeyDown',\n    value: function handleSliderKeyDown(event, key) {\n      if (this.props.disabled) {\n        return;\n      }\n      switch (event.keyCode) {\n        case _keyCodes.LEFT_ARROW:\n        case _keyCodes.DOWN_ARROW:\n          event.preventDefault();\n          this.decrementValue(key);\n          break;\n        case _keyCodes.RIGHT_ARROW:\n        case _keyCodes.UP_ARROW:\n          event.preventDefault();\n          this.incrementValue(key);\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Handle any \"mousedown\" event received by the track\n     * @private\n     * @param {SyntheticEvent} event\n     * @param {Point} position\n     * @return {void}\n     */\n  }, {\n    key: 'handleTrackMouseDown',\n    value: function handleTrackMouseDown(event, position) {\n      if (this.props.disabled) {\n        return;\n      }\n      var _props2 = this.props,\n        maxValue = _props2.maxValue,\n        minValue = _props2.minValue,\n        _props2$value = _props2.value,\n        max = _props2$value.max,\n        min = _props2$value.min;\n      event.preventDefault();\n      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());\n      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);\n      if (!this.props.draggableTrack || stepValue > max || stepValue < min) {\n        this.updatePosition(this.getKeyByPosition(position), position);\n      }\n    }\n\n    /**\n     * Handle the start of any mouse/touch event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'handleInteractionStart',\n    value: function handleInteractionStart() {\n      if (this.props.onChangeStart) {\n        this.props.onChangeStart(this.props.value);\n      }\n      if (this.props.onChangeComplete && !(0, _utils.isDefined)(this.startValue)) {\n        this.startValue = this.props.value;\n      }\n    }\n\n    /**\n     * Handle the end of any mouse/touch event\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: 'handleInteractionEnd',\n    value: function handleInteractionEnd() {\n      if (this.isSliderDragging) {\n        this.isSliderDragging = false;\n      }\n      if (!this.props.onChangeComplete || !(0, _utils.isDefined)(this.startValue)) {\n        return;\n      }\n      if (this.startValue !== this.props.value) {\n        this.props.onChangeComplete(this.props.value);\n      }\n      this.startValue = null;\n    }\n\n    /**\n     * Handle any \"keydown\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     * @return {void}\n     */\n  }, {\n    key: 'handleKeyDown',\n    value: function handleKeyDown(event) {\n      this.handleInteractionStart(event);\n    }\n\n    /**\n     * Handle any \"keyup\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     * @return {void}\n     */\n  }, {\n    key: 'handleKeyUp',\n    value: function handleKeyUp(event) {\n      this.handleInteractionEnd(event);\n    }\n\n    /**\n     * Handle any \"mousedown\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     * @return {void}\n     */\n  }, {\n    key: 'handleMouseDown',\n    value: function handleMouseDown(event) {\n      this.handleInteractionStart(event);\n      this.addDocumentMouseUpListener();\n    }\n\n    /**\n     * Handle any \"mouseup\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     */\n  }, {\n    key: 'handleMouseUp',\n    value: function handleMouseUp(event) {\n      this.handleInteractionEnd(event);\n      this.removeDocumentMouseUpListener();\n    }\n\n    /**\n     * Handle any \"touchstart\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     * @return {void}\n     */\n  }, {\n    key: 'handleTouchStart',\n    value: function handleTouchStart(event) {\n      this.handleInteractionStart(event);\n      this.addDocumentTouchEndListener();\n    }\n\n    /**\n     * Handle any \"touchend\" event received by the component\n     * @private\n     * @param {SyntheticEvent} event\n     */\n  }, {\n    key: 'handleTouchEnd',\n    value: function handleTouchEnd(event) {\n      this.handleInteractionEnd(event);\n      this.removeDocumentTouchEndListener();\n    }\n\n    /**\n     * Return JSX of sliders\n     * @private\n     * @return {JSX.Element}\n     */\n  }, {\n    key: 'renderSliders',\n    value: function renderSliders() {\n      var _this3 = this;\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);\n      var keys = this.props.allowSameValues && this.lastKeyMoved === 'min' ? this.getKeys().reverse() : this.getKeys();\n      return keys.map(function (key) {\n        var value = values[key];\n        var percentage = percentages[key];\n        var _props3 = _this3.props,\n          maxValue = _props3.maxValue,\n          minValue = _props3.minValue;\n        if (key === 'min') {\n          maxValue = values.max;\n        } else {\n          minValue = values.min;\n        }\n        var slider = _react2.default.createElement(_slider2.default, {\n          ariaLabelledby: _this3.props.ariaLabelledby,\n          ariaControls: _this3.props.ariaControls,\n          classNames: _this3.props.classNames,\n          formatLabel: _this3.props.formatLabel,\n          key: key,\n          maxValue: maxValue,\n          minValue: minValue,\n          onSliderDrag: _this3.handleSliderDrag,\n          onSliderKeyDown: _this3.handleSliderKeyDown,\n          percentage: percentage,\n          type: key,\n          value: value\n        });\n        return slider;\n      });\n    }\n\n    /**\n     * Return JSX of hidden inputs\n     * @private\n     * @return {JSX.Element}\n     */\n  }, {\n    key: 'renderHiddenInputs',\n    value: function renderHiddenInputs() {\n      var _this4 = this;\n      if (!this.props.name) {\n        return [];\n      }\n      var isMultiValue = this.isMultiValue();\n      var values = valueTransformer.getValueFromProps(this.props, isMultiValue);\n      return this.getKeys().map(function (key) {\n        var value = values[key];\n        var name = isMultiValue ? '' + _this4.props.name + (0, _utils.captialize)(key) : _this4.props.name;\n        return _react2.default.createElement('input', {\n          key: key,\n          type: 'hidden',\n          name: name,\n          value: value\n        });\n      });\n    }\n\n    /**\n     * @ignore\n     * @override\n     * @return {JSX.Element}\n     */\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this5 = this;\n      var componentClassName = this.getComponentClassName();\n      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);\n      return _react2.default.createElement('div', {\n        'aria-disabled': this.props.disabled,\n        ref: function ref(node) {\n          _this5.node = node;\n        },\n        className: componentClassName,\n        onKeyDown: this.handleKeyDown,\n        onKeyUp: this.handleKeyUp,\n        onMouseDown: this.handleMouseDown,\n        onTouchStart: this.handleTouchStart\n      }, _react2.default.createElement(_label2.default, {\n        classNames: this.props.classNames,\n        formatLabel: this.props.formatLabel,\n        type: 'min'\n      }, this.props.minValue), _react2.default.createElement(_track2.default, {\n        classNames: this.props.classNames,\n        draggableTrack: this.props.draggableTrack,\n        ref: function ref(trackNode) {\n          _this5.trackNode = trackNode;\n        },\n        percentages: percentages,\n        onTrackDrag: this.handleTrackDrag,\n        onTrackMouseDown: this.handleTrackMouseDown\n      }, this.renderSliders()), _react2.default.createElement(_label2.default, {\n        classNames: this.props.classNames,\n        formatLabel: this.props.formatLabel,\n        type: 'max'\n      }, this.props.maxValue), this.renderHiddenInputs());\n    }\n  }]);\n  return InputRange;\n}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleSliderDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleSliderKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionEnd'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchEnd'), _class.prototype)), _class);\nexports.default = InputRange;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["../../../src/js/input-range/input-range.jsx"],"names":["valueTransformer","InputRange","Component","allowSameValues","bool","ariaLabelledby","string","ariaControls","classNames","objectOf","disabled","draggableTrack","formatLabel","func","maxValue","minValue","name","onChangeStart","onChange","isRequired","onChangeComplete","step","number","value","props","startValue","node","trackNode","isSliderDragging","lastKeyMoved","removeDocumentMouseUpListener","removeDocumentTouchEndListener","inputRange","disabledInputRange","getClientRect","position","values","getValueFromProps","isMultiValue","positions","getPositionsFromValues","getTrackClientRect","distanceToMin","min","distanceToMax","max","currentValues","isWithinRange","hasStepDifference","key","updatePositions","getValueFromPosition","transformedValues","getStepValueFromValue","updateValues","shouldUpdate","updateValue","ownerDocument","addEventListener","handleMouseUp","handleTouchEnd","removeEventListener","event","getPositionFromEvent","requestAnimationFrame","updatePosition","prevEvent","stepValue","prevPosition","prevValue","prevStepValue","offset","keyCode","preventDefault","decrementValue","incrementValue","getKeyByPosition","handleInteractionStart","handleInteractionEnd","addDocumentMouseUpListener","addDocumentTouchEndListener","percentages","getPercentagesFromValues","keys","getKeys","reverse","map","percentage","slider","handleSliderDrag","handleSliderKeyDown","componentClassName","getComponentClassName","handleKeyDown","handleKeyUp","handleMouseDown","handleTrackDrag","renderSliders","renderHiddenInputs"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport autobind from 'autobind-decorator';\nimport * as valueTransformer from './value-transformer';\nimport DEFAULT_CLASS_NAMES from './default-class-names';\nimport Label from './label';\nimport rangePropType from './range-prop-type';\nimport valuePropType from './value-prop-type';\nimport Slider from './slider';\nimport Track from './track';\nimport { captialize, distanceTo, isDefined, isObject, length } from '../utils';\nimport { DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, UP_ARROW } from './key-codes';\n\n/**\n * A React component that allows users to input numeric values within a range\n * by dragging its sliders.\n */\nexport default class InputRange extends React.Component {\n  /**\n   * @ignore\n   * @override\n   * @return {Object}\n   */\n  static get propTypes() {\n    return {\n      allowSameValues: PropTypes.bool,\n      ariaLabelledby: PropTypes.string,\n      ariaControls: PropTypes.string,\n      classNames: PropTypes.objectOf(PropTypes.string),\n      disabled: PropTypes.bool,\n      draggableTrack: PropTypes.bool,\n      formatLabel: PropTypes.func,\n      maxValue: rangePropType,\n      minValue: rangePropType,\n      name: PropTypes.string,\n      onChangeStart: PropTypes.func,\n      onChange: PropTypes.func.isRequired,\n      onChangeComplete: PropTypes.func,\n      step: PropTypes.number,\n      value: valuePropType,\n    };\n  }\n\n  /**\n   * @ignore\n   * @override\n   * @return {Object}\n   */\n  static get defaultProps() {\n    return {\n      allowSameValues: false,\n      classNames: DEFAULT_CLASS_NAMES,\n      disabled: false,\n      maxValue: 10,\n      minValue: 0,\n      step: 1,\n    };\n  }\n\n  /**\n   * @param {Object} props\n   * @param {boolean} [props.allowSameValues]\n   * @param {string} [props.ariaLabelledby]\n   * @param {string} [props.ariaControls]\n   * @param {InputRangeClassNames} [props.classNames]\n   * @param {boolean} [props.disabled = false]\n   * @param {Function} [props.formatLabel]\n   * @param {number|Range} [props.maxValue = 10]\n   * @param {number|Range} [props.minValue = 0]\n   * @param {string} [props.name]\n   * @param {string} props.onChange\n   * @param {Function} [props.onChangeComplete]\n   * @param {Function} [props.onChangeStart]\n   * @param {number} [props.step = 1]\n   * @param {number|Range} props.value\n   */\n  constructor(props) {\n    super(props);\n\n    /**\n     * @private\n     * @type {?number}\n     */\n    this.startValue = null;\n\n    /**\n     * @private\n     * @type {?Component}\n     */\n    this.node = null;\n\n    /**\n     * @private\n     * @type {?Component}\n     */\n    this.trackNode = null;\n\n    /**\n     * @private\n     * @type {bool}\n     */\n    this.isSliderDragging = false;\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.lastKeyMoved = null;\n  }\n\n  /**\n   * @ignore\n   * @override\n   * @return {void}\n   */\n  componentWillUnmount() {\n    this.removeDocumentMouseUpListener();\n    this.removeDocumentTouchEndListener();\n  }\n\n  /**\n   * Return the CSS class name of the component\n   * @private\n   * @return {string}\n   */\n  getComponentClassName() {\n    if (!this.props.disabled) {\n      return this.props.classNames.inputRange;\n    }\n\n    return this.props.classNames.disabledInputRange;\n  }\n\n  /**\n   * Return the bounding rect of the track\n   * @private\n   * @return {ClientRect}\n   */\n  getTrackClientRect() {\n    return this.trackNode.getClientRect();\n  }\n\n  /**\n   * Return the slider key closest to a point\n   * @private\n   * @param {Point} position\n   * @return {string}\n   */\n  getKeyByPosition(position) {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());\n\n    if (this.isMultiValue()) {\n      const distanceToMin = distanceTo(position, positions.min);\n      const distanceToMax = distanceTo(position, positions.max);\n\n      if (distanceToMin < distanceToMax) {\n        return 'min';\n      }\n    }\n\n    return 'max';\n  }\n\n  /**\n   * Return all the slider keys\n   * @private\n   * @return {string[]}\n   */\n  getKeys() {\n    if (this.isMultiValue()) {\n      return ['min', 'max'];\n    }\n\n    return ['max'];\n  }\n\n  /**\n   * Return true if the difference between the new and the current value is\n   * greater or equal to the step amount of the component\n   * @private\n   * @param {Range} values\n   * @return {boolean}\n   */\n  hasStepDifference(values) {\n    const currentValues = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n\n    return length(values.min, currentValues.min) >= this.props.step ||\n           length(values.max, currentValues.max) >= this.props.step;\n  }\n\n  /**\n   * Return true if the component accepts a min and max value\n   * @private\n   * @return {boolean}\n   */\n  isMultiValue() {\n    return isObject(this.props.value);\n  }\n\n  /**\n   * Return true if the range is within the max and min value of the component\n   * @private\n   * @param {Range} values\n   * @return {boolean}\n   */\n  isWithinRange(values) {\n    if (this.isMultiValue()) {\n      return values.min >= this.props.minValue &&\n             values.max <= this.props.maxValue &&\n             this.props.allowSameValues\n              ? values.min <= values.max\n              : values.min < values.max;\n    }\n\n    return values.max >= this.props.minValue && values.max <= this.props.maxValue;\n  }\n\n  /**\n   * Return true if the new value should trigger a render\n   * @private\n   * @param {Range} values\n   * @return {boolean}\n   */\n  shouldUpdate(values) {\n    return this.isWithinRange(values) && this.hasStepDifference(values);\n  }\n\n  /**\n   * Update the position of a slider\n   * @private\n   * @param {string} key\n   * @param {Point} position\n   * @return {void}\n   */\n  updatePosition(key, position) {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());\n\n    positions[key] = position;\n    this.lastKeyMoved = key;\n\n    this.updatePositions(positions);\n  }\n\n  /**\n   * Update the positions of multiple sliders\n   * @private\n   * @param {Object} positions\n   * @param {Point} positions.min\n   * @param {Point} positions.max\n   * @return {void}\n   */\n  updatePositions(positions) {\n    const values = {\n      min: valueTransformer.getValueFromPosition(positions.min, this.props.minValue, this.props.maxValue, this.getTrackClientRect()),\n      max: valueTransformer.getValueFromPosition(positions.max, this.props.minValue, this.props.maxValue, this.getTrackClientRect()),\n    };\n\n    const transformedValues = {\n      min: valueTransformer.getStepValueFromValue(values.min, this.props.step),\n      max: valueTransformer.getStepValueFromValue(values.max, this.props.step),\n    };\n\n    this.updateValues(transformedValues);\n  }\n\n  /**\n   * Update the value of a slider\n   * @private\n   * @param {string} key\n   * @param {number} value\n   * @return {void}\n   */\n  updateValue(key, value) {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n\n    values[key] = value;\n\n    this.updateValues(values);\n  }\n\n  /**\n   * Update the values of multiple sliders\n   * @private\n   * @param {Range|number} values\n   * @return {void}\n   */\n  updateValues(values) {\n    if (!this.shouldUpdate(values)) {\n      return;\n    }\n\n    this.props.onChange(this.isMultiValue() ? values : values.max);\n  }\n\n  /**\n   * Increment the value of a slider by key name\n   * @private\n   * @param {string} key\n   * @return {void}\n   */\n  incrementValue(key) {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const value = values[key] + this.props.step;\n\n    this.updateValue(key, value);\n  }\n\n  /**\n   * Decrement the value of a slider by key name\n   * @private\n   * @param {string} key\n   * @return {void}\n   */\n  decrementValue(key) {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const value = values[key] - this.props.step;\n\n    this.updateValue(key, value);\n  }\n\n  /**\n   * Listen to mouseup event\n   * @private\n   * @return {void}\n   */\n  addDocumentMouseUpListener() {\n    this.removeDocumentMouseUpListener();\n    this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);\n  }\n\n  /**\n   * Listen to touchend event\n   * @private\n   * @return {void}\n   */\n  addDocumentTouchEndListener() {\n    this.removeDocumentTouchEndListener();\n    this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);\n  }\n\n  /**\n   * Stop listening to mouseup event\n   * @private\n   * @return {void}\n   */\n  removeDocumentMouseUpListener() {\n    this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);\n  }\n\n  /**\n   * Stop listening to touchend event\n   * @private\n   * @return {void}\n   */\n  removeDocumentTouchEndListener() {\n    this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);\n  }\n\n  /**\n   * Handle any \"mousemove\" event received by the slider\n   * @private\n   * @param {SyntheticEvent} event\n   * @param {string} key\n   * @return {void}\n   */\n  @autobind\n  handleSliderDrag(event, key) {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());\n    this.isSliderDragging = true;\n    requestAnimationFrame(() => this.updatePosition(key, position));\n  }\n\n  /**\n   * Handle any \"mousemove\" event received by the track\n   * @private\n   * @param {SyntheticEvent} event\n   * @return {void}\n   */\n  @autobind\n  handleTrackDrag(event, prevEvent) {\n    if (this.props.disabled || !this.props.draggableTrack || this.isSliderDragging) {\n      return;\n    }\n\n    const {\n      maxValue,\n      minValue,\n      value: { max, min },\n    } = this.props;\n\n    const position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());\n    const value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());\n    const stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);\n\n    const prevPosition = valueTransformer.getPositionFromEvent(prevEvent, this.getTrackClientRect());\n    const prevValue = valueTransformer.getValueFromPosition(prevPosition, minValue, maxValue, this.getTrackClientRect());\n    const prevStepValue = valueTransformer.getStepValueFromValue(prevValue, this.props.step);\n\n    const offset = prevStepValue - stepValue;\n\n    const transformedValues = {\n      min: min - offset,\n      max: max - offset,\n    };\n\n    this.updateValues(transformedValues);\n  }\n\n  /**\n   * Handle any \"keydown\" event received by the slider\n   * @private\n   * @param {SyntheticEvent} event\n   * @param {string} key\n   * @return {void}\n   */\n  @autobind\n  handleSliderKeyDown(event, key) {\n    if (this.props.disabled) {\n      return;\n    }\n\n    switch (event.keyCode) {\n    case LEFT_ARROW:\n    case DOWN_ARROW:\n      event.preventDefault();\n      this.decrementValue(key);\n      break;\n\n    case RIGHT_ARROW:\n    case UP_ARROW:\n      event.preventDefault();\n      this.incrementValue(key);\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  /**\n   * Handle any \"mousedown\" event received by the track\n   * @private\n   * @param {SyntheticEvent} event\n   * @param {Point} position\n   * @return {void}\n   */\n  @autobind\n  handleTrackMouseDown(event, position) {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const {\n      maxValue,\n      minValue,\n      value: { max, min },\n    } = this.props;\n\n    event.preventDefault();\n\n    const value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());\n    const stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);\n\n    if (!this.props.draggableTrack || stepValue > max || stepValue < min) {\n      this.updatePosition(this.getKeyByPosition(position), position);\n    }\n  }\n\n  /**\n   * Handle the start of any mouse/touch event\n   * @private\n   * @return {void}\n   */\n  @autobind\n  handleInteractionStart() {\n    if (this.props.onChangeStart) {\n      this.props.onChangeStart(this.props.value);\n    }\n\n    if (this.props.onChangeComplete && !isDefined(this.startValue)) {\n      this.startValue = this.props.value;\n    }\n  }\n\n  /**\n   * Handle the end of any mouse/touch event\n   * @private\n   * @return {void}\n   */\n  @autobind\n  handleInteractionEnd() {\n    if (this.isSliderDragging) {\n      this.isSliderDragging = false;\n    }\n\n    if (!this.props.onChangeComplete || !isDefined(this.startValue)) {\n      return;\n    }\n\n    if (this.startValue !== this.props.value) {\n      this.props.onChangeComplete(this.props.value);\n    }\n\n    this.startValue = null;\n  }\n\n  /**\n   * Handle any \"keydown\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   * @return {void}\n   */\n  @autobind\n  handleKeyDown(event) {\n    this.handleInteractionStart(event);\n  }\n\n  /**\n   * Handle any \"keyup\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   * @return {void}\n   */\n  @autobind\n  handleKeyUp(event) {\n    this.handleInteractionEnd(event);\n  }\n\n  /**\n   * Handle any \"mousedown\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   * @return {void}\n   */\n  @autobind\n  handleMouseDown(event) {\n    this.handleInteractionStart(event);\n    this.addDocumentMouseUpListener();\n  }\n\n  /**\n   * Handle any \"mouseup\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   */\n  @autobind\n  handleMouseUp(event) {\n    this.handleInteractionEnd(event);\n    this.removeDocumentMouseUpListener();\n  }\n\n  /**\n   * Handle any \"touchstart\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   * @return {void}\n   */\n  @autobind\n  handleTouchStart(event) {\n    this.handleInteractionStart(event);\n    this.addDocumentTouchEndListener();\n  }\n\n  /**\n   * Handle any \"touchend\" event received by the component\n   * @private\n   * @param {SyntheticEvent} event\n   */\n  @autobind\n  handleTouchEnd(event) {\n    this.handleInteractionEnd(event);\n    this.removeDocumentTouchEndListener();\n  }\n\n  /**\n   * Return JSX of sliders\n   * @private\n   * @return {JSX.Element}\n   */\n  renderSliders() {\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);\n    const keys = this.props.allowSameValues &&\n      this.lastKeyMoved === 'min'\n      ? this.getKeys().reverse()\n      : this.getKeys();\n\n    return keys.map((key) => {\n      const value = values[key];\n      const percentage = percentages[key];\n\n      let { maxValue, minValue } = this.props;\n\n      if (key === 'min') {\n        maxValue = values.max;\n      } else {\n        minValue = values.min;\n      }\n\n      const slider = (\n        <Slider\n          ariaLabelledby={this.props.ariaLabelledby}\n          ariaControls={this.props.ariaControls}\n          classNames={this.props.classNames}\n          formatLabel={this.props.formatLabel}\n          key={key}\n          maxValue={maxValue}\n          minValue={minValue}\n          onSliderDrag={this.handleSliderDrag}\n          onSliderKeyDown={this.handleSliderKeyDown}\n          percentage={percentage}\n          type={key}\n          value={value} />\n      );\n\n      return slider;\n    });\n  }\n\n  /**\n   * Return JSX of hidden inputs\n   * @private\n   * @return {JSX.Element}\n   */\n  renderHiddenInputs() {\n    if (!this.props.name) {\n      return [];\n    }\n\n    const isMultiValue = this.isMultiValue();\n    const values = valueTransformer.getValueFromProps(this.props, isMultiValue);\n\n    return this.getKeys().map((key) => {\n      const value = values[key];\n      const name = isMultiValue ? `${this.props.name}${captialize(key)}` : this.props.name;\n\n      return (\n        <input key={key} type=\"hidden\" name={name} value={value} />\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   * @override\n   * @return {JSX.Element}\n   */\n  render() {\n    const componentClassName = this.getComponentClassName();\n    const values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());\n    const percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);\n\n    return (\n      <div\n        aria-disabled={this.props.disabled}\n        ref={(node) => { this.node = node; }}\n        className={componentClassName}\n        onKeyDown={this.handleKeyDown}\n        onKeyUp={this.handleKeyUp}\n        onMouseDown={this.handleMouseDown}\n        onTouchStart={this.handleTouchStart}>\n        <Label\n          classNames={this.props.classNames}\n          formatLabel={this.props.formatLabel}\n          type=\"min\">\n          {this.props.minValue}\n        </Label>\n\n        <Track\n          classNames={this.props.classNames}\n          draggableTrack={this.props.draggableTrack}\n          ref={(trackNode) => { this.trackNode = trackNode; }}\n          percentages={percentages}\n          onTrackDrag={this.handleTrackDrag}\n          onTrackMouseDown={this.handleTrackMouseDown}>\n\n          {this.renderSliders()}\n        </Track>\n\n        <Label\n          classNames={this.props.classNames}\n          formatLabel={this.props.formatLabel}\n          type=\"max\">\n          {this.props.maxValue}\n        </Label>\n\n        {this.renderHiddenInputs()}\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}